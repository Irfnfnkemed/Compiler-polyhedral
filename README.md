# Compiler-polyhedral

这是在Mx*基础上构建的多面体编译器。

实现了多面体编译器的主要流程：模型提取->依赖分析->调度变换

## 传统编译器优化

### Mem2Reg

利用Tarjan算法建立支配树

### 内联 Inline

在IR上建立函数调用图，通过Tarjan求解强连通分量作为可否内联的判据

同时亦在ASM上进行二次内联

### 激进的死代码消除 ADCE

建立反图，利用支配树进行计算

### 稀疏常量传播 SCCP

在原始算法的基础上添加了`copy`状态，可以处理诸如 `1+x+1` 的优化合并

### 其他

块内推迟全局变量的store,全局变量局部化...

## 模型提取

### 分析循环代码的合法性

索引变量唯一、步长一致、上下界固定、仅有访存操作……

用类似 Semantic check 的方式实现

### 提取索引变量的范围

在合法性分析的同时，提取索引变量的范围，并做正规化处理

如 `for(int i = 1; i < 100; i += 2)    ->   index<i> : from 1 to 99 step 2`

### 提取访存地址 

将访存变量与对应的下标地址对应起来

如 `a[i+1][2*j] = ...    ->    write a : [(coe:1, var: i), bias:1][(coe:1, var: j), bias: 0]`

### 建立迭代空间

每个索引变量为一个维度，同一索引变量下，语句的顺序为一个维度
迭代空间中的字典序即为初始计算顺序

![img.png](img.png)

## 依赖分析

### 提取访存地址到读/写集的映射

根据提取出的访存地址，建立读/写集合中，变量的访存地址下标的映射

如 `a[i+1][2*j] = ...  ->  write a : [(coe:1, var: i), bias:1][(coe:1, var: j), bias: 0] `
      ->    `write-set:  a -> [(coe:1, var: i), bias:1][(coe:1, var: j), bias: 0] `

### 生成读后写/写后读/写后写三种依赖关系

根据读/写集合 $f_{R/W} (var)=S_{R/W}$ ，分别生成读后写/写后读/写后写的依赖关系: $f_W^{-1}f_W, f_W^{-1}f_R, f_R^{-1}f_W$

### 加入字典序依赖

处理字典序依赖，将字典序中的or的部分依次拆开，作用在前面的依赖上

### 生成依赖多面体

通过一系列操作，得到若干个依赖多面体 $P_e\vec{x}\le \vec{b}$

## 调度变换

### 寻找符合调度合法性不等式的仿射调度函数 $\phi(x):R^n->R^n$

Pluto算法在考虑并行性的同时，也考虑的分块开销

(弱)合法性不等式: 仿射变换 $\phi(x)$ 应满足:  $u\Gamma v -> \phi(u)\preceq \phi(v)$

Pluto算法中利用 $max_{lexi} (-\phi(u)+\phi(v))\preceq \gamma$  来估算变换后分块后的通信代价上限，$\gamma$ 是关于程序常量和索引变量的仿射函数

Pltuo算法通过最小化 $\gamma$ 中待定系数的字典序求出最佳变换方案，变换后可以任意分块

### 根据Farkas引理消除双线性

![img_1.png](img_1.png)

根据Farkas引理，可以将约束中诸如$c_{ij} x$的双线性变量消去，转为线性约束

### 调用Cplex求解整数线性规划

因为求解整数线性规划是NP-hard问题，所以我调用了IBM的Cplex工具包来辅助求解

### 利用Hermite正规型计算step

得到变换矩阵T后，还需要对原本的循环进行重建

利用Hermite正规型 𝐻=𝑇𝑈 ，H的对角线元素即为变换后索引变量的step 

### 利用Fourier-Motzkin消去法计算上下界

得到step后还需要重建变换后索引变量的上下界

利用Fourier-Motzkin消去法，由内向外的逐一消去变量，计算上下界
